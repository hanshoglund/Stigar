; load "~/Stigar/Stigar.vitry"

; =============================================================================
; Stigar - for player piano
; Hans Hoglund (2011)
; Vitry v0.1.0
; =============================================================================
module Hans.Music.Stigar


fetchDeviceBy = `num
; deviceNum     = 3
deviceNum     = 20
deviceName    = "Port 8"
channel       = 0
testPitch     = 108
                   
minPitch = 21
numPitch = 88

down     = `down
up       = `up
unaCorda = `unaCorda
treCorde = `treCorde

testSeq = 
    [down, unaCorda, (testPitch, 20, 500), (testPitch, 0, 0), up, treCorde]






onOff ps vs ds = zip3L 
                    dupL ps
                    interlL vs (repeat 0)
                    interlL ds (repeat 0)

walk start = unfold (fn (x) (x, (x + (random 2) * 2 - 1))) start



walkAndSplit start n = 
    let path = take n (walk start)
        final = last path
        path ++ delay (fn (_) interlL (walkAndSplit final n) (walkAndSplit final n))
       
alternateOff xs = interlL xs (repeat 0)

walkAndSplitWith start n xs ys = 
    let path = take n (walk start)
        xs1   = take n xs
        ys1   = take n ys
        xs2   = drop n xs 
        ys2   = drop n ys 
        final = last path
        zip3 (dup path) (alternateOff (take n xs)) (dup (take n ys))
            ++ delay (fn (_) 
                interlL 
                    walkAndSplitWith final n xs2 ys2 
                    walkAndSplitWith (final + 10) n xs2 ys2)

events2 = 
    ; [down, unaCorda, (60, 5, 0), (62, 5, 1500), up, (60, 0, 0), (62, 0, 1500), treCorde]
    ; onOff (walkAndSplit 60 10) (1 ... 128) (repeat 150)
    (walkAndSplitWith 60 5 (repeat 5) (repeat 300))


events = take 50000 events2







; ============================================================
; Main program

help _ = do print "============================================================"
            print " Stigar - for player piano                                  "
            print " Hans Hoglund (2011)                                        "
            print "============================================================"
            print "    p () or printDevices ()                                 "
            print "    t () or test ()                                          "
            print "    r () or run ()                                          "
            print "    deviceByName name                                       "
            print "    deviceByNum  n                                          "
            print "============================================================"


test _ = do
            dev = device ()
            recv = openDevAndFetchRecv dev
            play recv testSeq
            closeDev dev
            ()
run _  = do
            dev = device ()
            recv = openDevAndFetchRecv dev
            play recv events
            closeDev dev
            ()
            




; Send all notes off
; allOff r = print (map (fn (i) do (on r i 0) i) (1 ... 128))

; Plays a list of events
; Blocks the current thread
;   [(pitch, vel, dur)] -> [(pitch, vel, dur)]
play r events = foldl playEvent r events
playEvent r action =
    match action
        (pitch, vel, dur) = do  on r pitch vel
                            sleep dur
                            r
        _:down            = do ped r true
                            r
        _:up              = do ped r false
                            r
        _:unaCorda        = do ucPed r true
                            r
        _:treCorde        = do ucPed r false
                            r

p _ = printDevices ()
t _ = test ()
r _ = run ()
main = help ()



; ============================================================
; MIDI backend

NOTE_ON        = 144
NOTE_OFF       = 128
CONTROL_CHANGE = 176
SOST_PED       = 64
UNA_CORDA_PED  = 67

MidiSystem        = class "javax.sound.midi.MidiSystem"
MidiDevice        = class "javax.sound.midi.MidiDevice"
MidiDeviceInfo    = class "javax.sound.midi.MidiDevice$Info"
MidiMessage       = class "javax.sound.midi.MidiMessage"
ShortMessage      = class "javax.sound.midi.ShortMessage"
Receiver          = class "javax.sound.midi.Receiver"
BigInteger        = class "java.math.BigInteger"

getMidiDeviceInfo = method MidiSystem "getMidiDeviceInfo" () .. seq
getMidiDevice     = method MidiSystem "getMidiDevice" [ MidiDeviceInfo ]
setMessage        = method ShortMessage "setMessage" [ `int, `int, `int, `int ]
send              = method Receiver "send" [ MidiMessage, `long ]
intValue          = method BigInteger "intValue" ()
longValue         = method BigInteger "longValue" ()

printDevices _ = do print "\nDevices:"
                    join "\n" (getMidiDeviceInfo ())
deviceByName name = getMidiDevice
                        find (string .. (== name)) (getMidiDeviceInfo ())
deviceByNum n     = getMidiDevice
                        index n (getMidiDeviceInfo ())
device _          = match fetchDeviceBy
                        _:`num = deviceByNum deviceNum
                        _:`name = deviceByName deviceName
openDevAndFetchRecv dev =
    do (method MidiDevice "open" ()) dev
       (method MidiDevice "getReceiver" ()) dev
closeDev = method MidiDevice "close" ()

makeMsg cmd ch data1 data2 =
    do  msg = new ShortMessage
        setMessage msg (intValue cmd) (intValue ch) (intValue data1) (intValue data2)
        msg

sendMsg recv msg =
    send recv msg (longValue 0)


; on  r pitch vel = sendMsg r (makeMsg NOTE_ON channel pitch vel)

on  r pitch vel = do (print (pitch, vel))
                     sendMsg r (makeMsg NOTE_ON channel pitch vel)


off r pitch     = sendMsg r (makeMsg NOTE_OFF channel pitch 0)
ped r down      =
    if down
        sendMsg r (makeMsg CONTROL_CHANGE channel SOST_PED 64)
        sendMsg r (makeMsg CONTROL_CHANGE channel SOST_PED 0)
ucPed r down    =
    if down
        sendMsg r (makeMsg CONTROL_CHANGE channel UNA_CORDA_PED 64)
        sendMsg r (makeMsg CONTROL_CHANGE channel UNA_CORDA_PED 0)
; sleep           = longValue .. method (class "Thread") "sleep" [ `long ]





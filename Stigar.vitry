; load "~/Stigar/Stigar.vitry"

; =============================================================================
; Stigar - for player piano
; Hans Hoglund (2011)
; Vitry v0.1.0
; =============================================================================
module Hans.Music.Stigar


fetchDeviceBy = `name
deviceNum     = 20
deviceName    = "Port 8"
channel       = 0
testPitch     = 108

down     = `down
up       = `up
unaCorda = `unaCorda
treCorde = `treCorde

testSeq = 
    [down, unaCorda, (testPitch, 50, 500), (testPitch, 0, 0), up, treCorde]

events = 
    [down, unaCorda, (60, 5, 0), (62, 5, 1500), up, (60, 0, 0), (62, 0, 1500), treCorde]



help _ = do print "============================================================"
            print " Stigar - for player piano                                  "
            print " Hans Hoglund (2011)                                        "
            print "============================================================"
            print "    p () or printDevices ()                                 "
            print "    t () or test ()                                          "
            print "    r () or run ()                                          "
            print "    deviceByName name                                       "
            print "    deviceByNum  n                                          "
            print "============================================================"


test _ = do
            dev = device ()
            recv = openDevAndFetchRecv dev
            play recv testSeq
            closeDev dev
            ()
run _  = do
            dev = device ()
            recv = openDevAndFetchRecv dev
            play recv events
            closeDev dev
            ()


; Plays a list of events
; Blocks the current thread
;   [(pitch, vel, dur)] -> [(pitch, vel, dur)]
play r events = foldl playEvent r events
playEvent r action =
    match action
        (pitch, vel, dur) = do  on r pitch vel
                            sleep dur
                            r
        _:down            = do ped r true
                            r
        _:up              = do ped r false
                            r
        _:unaCorda        = do ucPed r true
                            r
        _:treCorde        = do ucPed r false
                            r

p _ = printDevices ()
t _ = test ()
r _ = run ()
main = help ()


; ============================================================
; MIDI backend

NOTE_ON        = 144
NOTE_OFF       = 128
CONTROL_CHANGE = 176
SOST_PED       = 64
UNA_CORDA_PED  = 67

MidiSystem        = class "javax.sound.midi.MidiSystem"
MidiDevice        = class "javax.sound.midi.MidiDevice"
MidiDeviceInfo    = class "javax.sound.midi.MidiDevice$Info"
MidiMessage       = class "javax.sound.midi.MidiMessage"
ShortMessage      = class "javax.sound.midi.ShortMessage"
Receiver          = class "javax.sound.midi.Receiver"
BigInteger        = class "java.math.BigInteger"

getMidiDeviceInfo = method MidiSystem "getMidiDeviceInfo" () .. seq
getMidiDevice     = method MidiSystem "getMidiDevice" [ MidiDeviceInfo ]
setMessage        = method ShortMessage "setMessage" [ `int, `int, `int, `int ]
send              = method Receiver "send" [ MidiMessage, `long ]
intValue          = method BigInteger "intValue" ()
longValue         = method BigInteger "longValue" ()

printDevices _ = do (print "\nDevices:")
                    map (string .. (++ "    ") .. print)
                        (getMidiDeviceInfo ())
deviceByName name = getMidiDevice
                        find (string .. (== name)) (getMidiDeviceInfo ())
deviceByNum n     = getMidiDevice
                        nth n (getMidiDeviceInfo ())
device _          = match fetchDeviceBy
                        _:`num = deviceByNum deviceNum
                        _:`name = deviceByName deviceName
openDevAndFetchRecv dev =
    do (method MidiDevice "open" ()) dev
       (method MidiDevice "getReceiver" ()) dev
closeDev = method MidiDevice "close" ()

makeMsg cmd ch data1 data2 =
    do  msg = new ShortMessage
        setMessage msg (intValue cmd) (intValue ch) (intValue data1) (intValue data2)
        msg

sendMsg recv msg =
    send recv msg (longValue 0)

on  r pitch vel = sendMsg r (makeMsg NOTE_ON channel pitch vel)
off r pitch     = sendMsg r (makeMsg NOTE_OFF channel pitch 0)
ped r down      =
    if down
        sendMsg r (makeMsg CONTROL_CHANGE channel SOST_PED 127)
        sendMsg r (makeMsg CONTROL_CHANGE channel SOST_PED 0)
ucPed r down    =
    if down
        sendMsg r (makeMsg CONTROL_CHANGE channel UNA_CORDA_PED 127)
        sendMsg r (makeMsg CONTROL_CHANGE channel UNA_CORDA_PED 0)
sleep           = longValue .. method (class "Thread") "sleep" [ `long ]




; ============================================================
; General stuff
; Add to standard library!


find pred = foldl (fn (x y) if (pred y) y else x) ()


(&&) x y =
    match (x, y)
        (_:true, _:true) = true
        (_:bool, _:bool) = false

(||) x y =
    match (x, y)
        (_:true, _:bool) = true
        (_:bool, _:true) = true
        (_:bool, _:bool) = false

(!=) x y = not (x == y)